## The Client

### Main Component

Diving into our actual component logic we'll start with the `Main` component, which we saw in [Instantiating the App](#instantiating-the-app) is a direct child of `StateProvider`, which itself a child of our base `App` component. Therefore, `Main` is where all our actual layout and logic begin. Here we see the `client/src/components/Main/Main.tsx` component.

```tsx
// File: client/src/components/Main/Main.tsx
// Components
import ProfileCard from '../Profile/ProfileCard';
import Search from '../Search/Search';
import TweetBox from '../Tweet/TweetBox';
import TweetList from '../Tweet/TweetList';
import NavigationBar from '../Navigation/NavigationBar';
// Layout
import { Col, Container, Row } from 'react-bootstrap';
// Libs
import React from 'react';
import { DgraphQueryExecutor, Queries } from 'dgraph-query-manager';
// Local
import { useDgraphGlobal } from '../../hooks/';
import { Route, Switch } from 'react-router-dom';
import { Action, ActionType } from '../../reducers/';
import config from '../../config';
import TweetModal from '../Tweet/TweetModal';
import Following from '../Profile/Following';
import Followers from '../Profile/Followers';

const Main = () => {
  // Default auth user
  const executor = new DgraphQueryExecutor(Queries.User.findFromEmail, {
    $email: config.user.defaultAuthEmail,
  });
  const [isLoading, response] = useDgraphGlobal({
    executor,
    action: new Action(ActionType.SET_AUTHENTICATED_USER),
    dependencies: [config.user.defaultAuthEmail],
  });

  return (
    <Container>
      <Route path={'/:screenName/status/:tweetUid'} component={TweetModal} />
      <NavigationBar />
      <Container className="AppContainer">
        <Row>
          <Col sm={4}>
            <Switch>
              <Route path={'/'} exact component={ProfileCard} />
              <Route path={'/search'} exact component={Search} />
              <Route path={'/:screenName'} component={ProfileCard} />
            </Switch>
          </Col>
          <Col>
            <TweetBox />
            <Switch>
              <Route path={'/:screenName/followers'} component={Followers} />
              <Route path={'/:screenName/following'} component={Following} />
              <Route
                path={[
                  '/',
                  '/:screenName',
                  '/search',
                  '/:screenName/status/:tweetUid',
                ]}
                component={TweetList}
              />
            </Switch>
          </Col>
        </Row>
      </Container>
    </Container>
  );
};

export default Main;
```

Anything that is to be rendered by a component must be included in its `return` value, so all business logic prior to rendering occurs above the return within a given function component. In this case, we start by instantiating a new `DgraphQueryExecutor`, which you can learn more about in the [Part 1 - Simplifying Query Execution]({{% ref "/#simplifying-query-execution" %}}) section. The `User.findFromEmail` `Query` lets us find a user by email, and we're passing a static value defined in `config.user.defaultAuthEmail`. Obviously, in a production application, this would be obtained from the user during login authentication, or perhaps from a session cookie. In this case, we don't bother adding user authentication logic to the app since it's unnecessary, so we're just hard-coding authentication for a single, specific user.

To accomplish this we're invoking a custom React hook called `useDgraphGlobal`, which can be found in the `client/src/hooks/dgraph/useDgraphGlobal.ts` [file](https://github.com/GabeStah/dgraph-twitter-clone/blob/master/client/src/hooks/dgraph/useDgraphGlobal.ts).

```ts
// Helpers
import { logger } from '../../helpers';
// Local
import { useStateContext } from '../../state';
// Libs
import { useEffect, useState } from 'react';
import { DgraphQueryExecutor, Serialization } from 'dgraph-query-manager';
import config from '../../config';
import { Action } from '../../reducers/';

/**
 * Custom React hook that performs the heavy lifting of data retrieval from Dgraph and uses global state.
 * Accepts a DgraphQueryExecutor and Action.
 * The Executor is executed and the result is attached to an Action which is dispatched to global state reducer.
 *
 * @param parameters.executor Executor to be executed.
 * @param parameters.action Action to be dispatched to reducer based on executor response.
 * @param parameters.dependencies Values that will trigger a re-render upon change.
 * @param parameters.invalid Determines if this hook is invalid.
 * @param parameters.allowFailure Allows failed result to still be dispatched to state.
 */
export const useDgraphGlobal = (parameters: {
  executor: DgraphQueryExecutor;
  action: Action;
  dependencies: any;
  invalid?: boolean;
  allowFailure?: boolean;
}): [boolean, Serialization] => {
  const {
    executor,
    action,
    dependencies,
    invalid,
    allowFailure = false,
  } = parameters;
  const [isLoading, setIsLoading]: [boolean, Function] = useState(false);
  const [response, setResponse]: [any, Function] = useState(undefined);

  // STATE
  const [, dispatch]: [any, Function] = useStateContext();

  // Call useEffect unconditionally.
  useEffect(() => {
    // Confirm validity
    if (!invalid) {
      executor
        .execute()
        .then(serialization => {
          setIsLoading(false);

          if (config.debug) {
            logger.info(
              `Serialized Response - action: %o, serialization: %o`,
              action,
              serialization
            );
            console.log(serialization);
          }

          if (serialization.success || allowFailure) {
            action.payload = serialization.response;
            dispatch(action);
            setResponse(serialization.response);
          }
        })
        .catch(exception => {
          logger.error(exception);
          setIsLoading(false);
        });
    } else {
      setIsLoading(true);
      logger.info(`Loading...`);
    }
  }, dependencies);

  return [isLoading, response];
};
```

The function documentation somewhat explains what's going on here, but the basic idea is this hook is passed a `DgraphQueryExecutor` and an `Action`. The `executor` is executed and the result, which is always a `Serialization` instance, is assigned to the `action.payload`. We then `dispatch()` that `action` obtained by calling the `useStateContext()` hook.

Something new here we haven't discussed yet is React's [`useEffect()`](https://reactjs.org/docs/hooks-effect.html) method. If you're familiar with React you may know that React class components rely upon built-in class methods to handle lifecycle events. These methods are `componentDidMount()`, `componentDidUpdate()`, and `componentWillUnmount()`. Each of those methods is automatically triggered at the appropriate moment in the component's lifecycle. You can read more about the React component lifecycle in the [official documentation](https://reactjs.org/docs/react-component.html#componentdidmount), but for now just consider that those three methods are different moments in a component lifecycle, so handling component state within a class component often requires placing the right logic within the correct `componentDid/Will` method.

However, with React hooks we can replace the need for all three of the above methods with the `useEffect()` hook. The purpose of `useEffect()` is to trigger _side effects_ after the component renders. Typically, such side effects are actions that may impact the component in some way, _but_ that are not necessary for initial rendering to take place. A good example is data retrieval, which is often a delayed process that requires an async/await contract to be fulfilled. You typically don't want to trigger such effects inside the rendering logic of your component, so adding those to the lifecycle event methods for class components (or inside `useEffect()` for function components) is ideal -- those effects are free to execute after rendering and only make further updates when a change is required.

Referring back to our `useDgraphGlobal()` hook above, we see the `useEffect()` call starts by checking for validity (a special argument that was needed elsewhere in the app). It then executes the passed `executor`. Upon successful execution the `serialization.response` property is assigned to the `action.payload` and then the action is dispatched to our main reducer class we looked at before. We also call a `useState()` hook to assign a `response` value _outside_ of the `useEffect()` method. This `response` object (which is the `serialization.response` we received inside the effect) is returned by `useDgraphGlobal()`.

{{% notice "note" %}} Keen observers may notice the odd use of a `Promise.then().catch()` block here, where elsewhere in the app we've typically used `async/await`. The reason for this is that, unfortunately, `useEffect()` hooks cannot accept `async` functions -- that is, a Promise cannot be passed as an argument to a `useEffect()` call. Therefore, we use the next best thing which is calling an async function _within_ the `useEffect()` anon function logic. The React team is working on adding data fetching capabilities through a feature called **Suspense**, which will be the preferred way to handle such retrieval in the future, but unfortunately [Suspense for data fetching is not ready](https://github.com/facebook/react/issues/14326#issuecomment-466378700) at time of writing. {{% /notice %}}

#### Hooking Into useDgraphGlobal

Back to our `Main` component, we can re-examine how the custom `useDgraphGlobal()` hook is used here.

```tsx
// File: client/src/components/Main/Main.tsx
// ...
const Main = () => {
  // Default auth user
  const executor = new DgraphQueryExecutor(Queries.User.findFromEmail, {
    $email: config.user.defaultAuthEmail,
  });
  const [isLoading, response] = useDgraphGlobal({
    executor,
    action: new Action(ActionType.SET_AUTHENTICATED_USER),
    dependencies: [config.user.defaultAuthEmail],
  });

  // ...
};
```

The `DgraphQueryExecutor` we pass is configured to execute the `User.findFromEmail` for our explicit email. The `Action` argument of `new Action(ActionType.SET_AUTHENTICATED_USER)` tells the `Reducer` class how it should change our global `State` based on the result of the `executor`.

```ts
// File: client/src/reducers/base/Reducer.ts
// ...
export const Reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case ActionType.SET_AUTHENTICATED_USER: {
      return {
        ...state,
        authUser: action.payload,
      };
    }
  }
  // ...
};
```

Here we see that the `Reducer` merely creates a new shallow copy of the `State` object, but first assigns the `authUser` property to the `action.payload` value, which itself was assigned to the executor's `Serialization.response` value. This logical structure makes it very simple to add new global state to our application in a few short steps:

1. Add a new property to the `State` class.
2. Add a new type to the `ActionType` enum.
3. Add a case to the `Reducer` logic for the new `ActionType`.

That's it! While all the state properties we're currently using are at the same "level", if we wanted to modify nested children of higher state properties we could start breaking out our `Reducer` into multiple sub-reducers and then combining the final state at the end.

#### Routing with React Router DOM

The [react-router-dom](https://reacttraining.com/react-router/web/guides/quick-start) library handles routing similarly to [ExpressJS](https://expressjs.com/). Our `Main` component renders a handful of `Route` components that are each passed a few properties.

```tsx
// File: client/src/components/Main/Main.tsx
// ...
return (
  <Container>
    <Route path={'/:screenName/status/:tweetUid'} component={TweetModal} />
    <NavigationBar />
    <Container className="AppContainer">
      <Row>
        <Col sm={4}>
          <Switch>
            <Route path={'/'} exact component={ProfileCard} />
            <Route path={'/search'} exact component={Search} />
            <Route path={'/:screenName'} component={ProfileCard} />
          </Switch>
        </Col>
        <Col>
          <TweetBox />
          <Switch>
            <Route path={'/:screenName/followers'} component={Followers} />
            <Route path={'/:screenName/following'} component={Following} />
            <Route
              path={[
                '/',
                '/:screenName',
                '/search',
                '/:screenName/status/:tweetUid',
              ]}
              component={TweetList}
            />
          </Switch>
        </Col>
      </Row>
    </Container>
  </Container>
);
// ...
```

The `path` property matches any path that the [path-to-regexp](https://github.com/pillarjs/path-to-regexp/tree/v1.7.0) dependency package understands. If a match is detected then the `Route` acts upon that based on the additional properties it was provided. For example, `<Route path={'/'} exact component={ProfileCard} />` will _only match_ the root path (`/`) and, if a match is found, it will render the `ProfileCard` component. Typically, **every** matching `Route` will render. However, the `Switch` component that wraps the trio of `Routes` above will only render the _first_ matching `Route` in the set, ignoring any remaining `Routes` below it. In this case, we're first checking if the user is at the root path. We have to use the `exact` property here because, otherwise, any `Route` with a `path` that starts with `/` will also match. If the user isn't at the root path then we check if they are at `/search`. If there's still no match, we finally assume the extra URI content following the root path `/` is a user `screenName` (just like [Twitter URLs](https://twitter.com/dgraphlabs)), so we match that and render the `ProfileCard` component.

### Navigation Components

Our navigation components consist of the `NavigationBar` and its single child component, `SearchBox`.

#### Navigation Bar

The `NavigationBar` component is just a simple Bootstrap nav bar that serves little purpose _except_ as a home for our `SearchBox` component.

```tsx
// File: client/src/components/Navigation/NavigationBar.tsx
// Components
import { Nav, Navbar } from 'react-bootstrap';
// Libs
import React from 'react';
import SearchBox from './SearchBox';

const NavigationBar = () => {
  return (
    <Navbar bg="light" fixed="top">
      <Navbar.Brand href="/">Dgraph + Twitter</Navbar.Brand>
      <Navbar.Toggle aria-controls="basic-navbar-nav" />
      <Navbar.Collapse key="basic-navbar-nav">
        <Nav className="mr-auto" />
        <SearchBox />
      </Navbar.Collapse>
    </Navbar>
  );
};

export default NavigationBar;
```

#### Search Box

The `SearchBox` [component](https://github.com/GabeStah/dgraph-twitter-clone/blob/master/client/src/components/Navigation/SearchBox.tsx) is primarily an input that uses local state and a feature of `react-router-dom` to redirect the user to our `/search` endpoint based on their search query.

```tsx
// File: client/src/components/Navigation/SearchBox.tsx
import React, { useState } from 'react';
import { Button, Form, FormControl } from 'react-bootstrap';
import { withRouter } from 'react-router-dom';

const SearchBox = ({ history }) => {
  const [currentText, setCurrentText] = useState('');

  const handleInputChange = event => {
    // Destructure textbox `value` field.
    const { value } = event.target;
    // Update params
    setCurrentText(value);
  };

  return (
    <>
      <Form
        inline
        onSubmit={async event => {
          event.preventDefault();
          if (!currentText || currentText.length === 0) {
            return;
          }

          // Redirect to search path.
          history.push(`/search?q=${currentText}`);
        }}
      >
        <FormControl
          id={'text'}
          className={'mr-sm-2'}
          placeholder={'Search Twitter'}
          type={'text'}
          value={currentText}
          onChange={handleInputChange}
        />
        <Button variant={'outline-success'} type={'submit'}>
          Search
        </Button>
      </Form>
    </>
  );
};

export default withRouter(SearchBox);
```

We start by creating a local `currentText` state that is initialized to an empty string. The form invokes `handleInputChange()` when the text value changes, which assigns the new value to our `currentText` state. The `Form.onSubmit()` event starts by preventing the default behavior, which is critical to do at the beginning of many React component event callbacks. To perform a redirect we use the `history` prop that was provided to the `SearchBox` component props object because we wrapped the caller at the bottom in [`withRouter`](https://reacttraining.com/react-router/web/api/withRouter) from `react-router-dom`. This trick let's us perform a simple redirect by adding a new entry to the history stack. In this case, we want to perform a search so we redirect to our `/search?q=` endpoint and include the `currentText` state value.

### Search Component

The `Search` [component](https://github.com/GabeStah/dgraph-twitter-clone/blob/master/client/src/components/Search/Search.tsx) is where things start to get rather interesting. We get to combine a lot of functionality from every aspect of our app to perform an efficient yet powerful search using a Dgraph query.

```tsx
// File: client/src/components/Search/Search.tsx
import React from 'react';
import { DgraphQueryExecutor, Queries } from 'dgraph-query-manager';
import { useDgraphGlobal } from '../../hooks/dgraph';
import { Action, ActionType } from '../../reducers/base';
import { Card, Image } from 'react-bootstrap';
import { useStateContext } from '../../state';

const Search = ({ location }) => {
  const [{ tweets }] = useStateContext();

  const cleanupQueryString = (query: string | null) => {
    let result;
    if (query) {
      result = query.replace('%23', '').replace('#', '');
    }
    return result;
  };

  const queryString = cleanupQueryString(
    new URLSearchParams(location.search).get('q')
  );

  const executor = new DgraphQueryExecutor(Queries.Search.search, {
    $query: queryString,
  });

  useDgraphGlobal({
    executor,
    action: new Action(ActionType.SET_TWEETS),
    // Re-render if query changes.
    dependencies: [queryString],
    invalid: undefined,
    // Accept empty results.
    allowFailure: true,
  });

  return (
    <Card className="SearchCard">
      <Card.Body>
        <div>
          <p>
            Search for <b>{queryString}</b> found {tweets ? tweets.length : 0}{' '}
            results.
          </p>
        </div>
      </Card.Body>
    </Card>
  );
};

export default Search;
```

Our component starts by calling the custom `useStateContext()` hook and destructuring the `tweets` property from it. This contains the global list of `Tweets` for our app, which is essentially used to render the main `TweetList` component we'll see a bit later. In this case, the `Search` component will be updating that state and we'll use the result to render a simple counter of how many tweets were returned from the search.

The `DgraphQueryExecutor` is using the `Search.search` `Query` which looks similar to the following.

```js
query find($query: string) {
  a as var(func: anyoftext(tweet.text, $query))
  var(func: anyoftext(hashtag.hashtag, $query)) {
    b as hashtags: ~tweet.hashtag
  }

  data(func: has(tweet.text)) @filter(uid(a) OR uid(b)) {
    uid
    expand(_all_) {
      uid
      expand(_all_)
    }
  }
}
```

The `Query` expects a `$query` parameter indicating what to search for, and looks in the `tweet.text` and `hashtag.hashtag` predicates for that text using one of GraphQL+-'s [full-text search](https://docs.dgraph.io/query-language/#full-text-search) functions, `anyoftext()`. We want a result consisting only of tweet nodes, but since the hashtag nodes referenced in the `tweet.hashtag` edge are separate nodes we need to combine the results of our pre-search before obtaining the final result set. We accomplish this by using GraphQL+- [var blocks](https://docs.dgraph.io/query-language/#var-blocks), which are blocks that begin with the `var` keyword and which are not returned in the results. We combine that capability with [value variables](https://docs.dgraph.io/query-language/#value-variables) that are written in the form of `varName as ...` to obtain a temporary list of scalar values. In this case, Dgraph recognizes the results of our two `var` blocks are nodes. We assign those node `uids` to temporary variables `a` and `b`, and then use those collections as part of the `@filter` for our final query. The end result is that we return only the subset of tweet nodes that _either_ have a `tweet.text` or a `tweet.hashtag { hashtag.hashtag }` predicate containing our search text.

To see this in action here we've got the above query looking for the search term `user`, which should return at least a handful of results in your local installation if you generated some dummy data during the app install.

<!-- prettier-ignore-start -->
{{< runnable >}}
{
  a as var(func: anyoftext(tweet.text, "user")) 
  var(func: anyoftext(hashtag.hashtag, "user")) {
    b as hashtags: ~tweet.hashtag
  }

  data(func: has(tweet.text)) @filter(uid(a) OR uid(b)) {
    uid
    expand(_all_) {
      uid
      expand(_all_)
    }
  }
}
{{</ runnable >}}
<!-- prettier-ignore-end -->

The search query above uses another GraphQL+- feature called [Reverse Edges](https://docs.dgraph.io/query-language/#reverse-edges). The tilde character preceding the `tweet.hashtag` predicate in the line `b as hashtags: ~tweet.hashtag` signifies that we're querying the _reverse edge_ between `tweet.hashtag` and `hashtag.hashtag`. To better illustrate this, take a look at the modified query below in which we're only seeking tweets where `tweet.hashtag` shares an edge with a `hashtag.hashtag` node that contains the search term of `user`.

<!-- prettier-ignore-start -->
{{< runnable >}}
{
  var(func: anyoftext(hashtag.hashtag, "user")) {
    b as hashtags: ~tweet.hashtag
  }

  data(func: has(tweet.text)) @filter(uid(b)) {
    uid
    count(uid)
    tweet.text
    tweet.hashtag {
      hashtag.hashtag
    }
  }
}
{{</ runnable >}}
<!-- prettier-ignore-end -->

Here's a sample of what that should return.

```json
{
  "uid": "0x106f",
  "tweet.text": "@Jarred_Schiller82 viral enable experiences #User-friendly #Persistent",
  "tweet.hashtag": [
    {
      "hashtag.hashtag": "User"
    },
    {
      "hashtag.hashtag": "Persistent"
    }
  ]
}
```

Notice that our query is structured such that `hashtag.hashtag` is a child node of `tweet.hashtag`. However, we are searching for "parent" tweet nodes that contain hashtags with `user` text, so we use a **reverse edge** (`~`) to look at the relationship in the opposite direction as normal. In our Dgraph [schema]({{% ref "/#schema" %}}) we added the `@reverse` directive to the `tweet.hashtag` predicate so Dgraph would automatically compute the reverse edge for us.

---

Back to the `Search` component logic. We saw how the client app uses the `useDgraphGlobal()` hook in the [Hooking Into useDgraphGlobal](#hooking-into-usedgraphglobal) section, but the call to that hook in the `Search` component has a few extra arguments to briefly discuss.

```ts
useDgraphGlobal({
  executor,
  action: new Action(ActionType.SET_TWEETS),
  // Re-render if query changes.
  dependencies: [queryString],
  invalid: undefined,
  // Accept empty results.
  allowFailure: true,
});
```

We know that the executor is executed and that the result is passed as a payload to the new `Action` which is a type of `SET_TWEETS`. The `dependencies` param is actually passed as the _second_ argument to the underlying `useEffect()` method. When React re-renders a component in which `useEffect()` was called (due to a state change or what not), before the `useEffect()` function is invoked _again_ React will first check the list of dependency arguments for changes in their value(s). If none of the dependencies have changed since the previous `useEffect()` invocation, React **will not** call the function passed to `useEffect()` after re-rendering the component. This is particularly useful when the side effect being called is not something that should be executed for every render.

So, in the case above our dependencies consist of just a single reference to our `queryString` value -- in other words, the actual text that is being searched for during this render. In our query example above, `queryString` would be equal to `user`. Thus, after the `Search` component renders initially and executes the underlying `useEffect()` hook that's part of our `useDgraphGlobal()` call, it will only trigger `useEffect()` again **if** the value of the `queryString` has changed. In other words, if a new search parameter is passed. Neato!

Setting `allowFailure` to `true` is useful when executing a query that _may_ not return any results. Since this is a user-generated search query, we have to account for this possibility, so setting `allowFailure` to true for this call still passes the `Serialization.response` to our `action.payload` and updates the `tweets` state accordingly.

The only other minor thing to mention is the destructured `location` property, which is [provided by](https://reacttraining.com/react-router/web/api/location) `react-router-dom`. The `location` object contains a bit of useful information such as the current path, query params, and so forth. We use it here to extract the `search` property params, since the `/search?q=user` path contains the actual text being searched for.

### Profile Components

Profile components provide basic user information for the currently authenticated **or** currently viewed user.

#### Profile Card

Let's take a look at the `ProfileCard` component, which is the identification card along the left side of the app containing user-specific profile information.

```tsx
// File: client/src/components/Profile/ProfileCard.tsx
// Components
import ProfileCardStats from './ProfileCardStats';
// Helpers
// Hooks
// Layout
import { Card, Image } from 'react-bootstrap';
// Libs
import { DgraphQueryExecutor, Queries } from 'dgraph-query-manager';
import React from 'react';
// Local
import { useStateContext } from '../../state';
import { useDgraphGlobal } from '../../hooks/';
import { Action, ActionType } from '../../reducers/';
import config from '../../config';

const ProfileCard = ({ match }) => {
  const screenName =
    match && match.params && match.params.screenName
      ? match.params.screenName
      : config.user.defaultAuthScreenName;

  const executorScreenName = new DgraphQueryExecutor(
    Queries.User.findFromScreenName,
    {
      $screenName: screenName,
    }
  );
  const [isScreenNameLoading, responseScreenName] = useDgraphGlobal({
    executor: executorScreenName,
    action: new Action(ActionType.SET_USER),
    // Re-render if match changes.
    dependencies: [screenName],
    // Invalid if screenName doesn't exist.
    invalid: !screenName,
  });

  const [{ user }] = useStateContext();

  const executorTweets = new DgraphQueryExecutor(Queries.Tweet.getAllForUser, {
    $id: user && user.uid ? user.uid.toString() : undefined,
  });
  const [isLoading, response] = useDgraphGlobal({
    executor: executorTweets,
    action: new Action(ActionType.SET_TWEETS),
    // Re-render if user changes.
    dependencies: [user],
    // Invalid if user doesn't exist.
    invalid: !user,
  });

  let content = <h3>Loading Profile</h3>;

  if (user) {
    const name = user['user.name'];
    const screenName = user['user.screenName'];
    content = (
      <Card className="ProfileCard">
        <a className="ProfileCard-bg" href={`/${screenName}`} />
        <Card.Body>
          <a href={`/${screenName}`} title={name}>
            <Image
              src={
                user['user.avatar']
                  ? user['user.avatar']
                  : 'https://www.gravatar.com/avatar/00000000000000000000000000000000'
              }
            />
          </a>

          <div>
            <div>
              <a href={`/${screenName}`}>{name}</a>
            </div>
            <span>
              <a href={`/${screenName}`}>
                <span>
                  @<b>{screenName}</b>
                </span>
              </a>
            </span>
          </div>

          <ProfileCardStats />
        </Card.Body>
      </Card>
    );
  } else {
    content = (
      <>
        <h3>No User Profile found.</h3>
      </>
    );
  }

  return content;
};

export default ProfileCard;
```

As you may recall one of the `Routes` in our `Main` component uses a path with a `:screenName` parameter and renders the `ProfileCard` if it matches.

```tsx
<Route path={'/:screenName'} component={ProfileCard} />
```

Therefore, the `ProfileCard` component first destructures the `match` property [provided by](https://reacttraining.com/react-router/web/api/match) `react-router-dom` and checks to see if the `screenName` param exists. If not, it assumes we've matched the root path instead (`/`), which was also routed to render this component, and uses the static `config.user.defaultAuthScreenName` value instead. As we saw in the [Main Component](#main-component) section, this static value is just used for demonstration purposes and would be retrieved from an authed user or session in a real-world app. The retrieved `screenName` value is then used in the `User.findFromScreenName` `Query` and that executor is passed to `useDgraphGlobal` to retrieve a matching `User` record with that particular `user.screenName`.

The `ActionType.SET_USER` causes our `Reducer` to update the `State.user` property with the retrieved value, so we also call the `useStateContext()` hook and destructure the `user` property to get whatever user is currently active. We then use another `Query` and executor to retrieve all `Tweets` for that user and dispatch it with the `ActionType.SET_TWEETS` action. It's worth noting that we used the same `ActionType` in the `Search` component, which illustrates the power of making our components self-contained. Regardless of where in the app we update the global list of tweets, we can use the same process and it will always have the same impact on the rest of the app.

The actual rendered HTML of `ProfileCard` creates some basic profile structure for the user, including their avatar if applicable, and also renders the `ProfileCardStats` component.

#### Profile Card Stats

You may have noticed the `ProfileCard` component doesn't pass any props to the `ProfileCardStats` component. Therefore, as you'll see in the code, `ProfileCardStats` doesn't expect a props argument.

```tsx
// File: client/src/components/Profile/ProfileCardStats.tsx
// Components
// Hooks
// Layout
import { Col, Row } from 'react-bootstrap';
// Libs
import React from 'react';
import { useStateContext } from '../../state';

const ProfileCardStats = () => {
  const [{ user }] = useStateContext();

  let content = <h3>Loading Stats</h3>;

  if (user) {
    const screenName = user['user.screenName'];
    content = (
      <Row className="ProfileCardStat" noGutters={true}>
        <Col xs={3}>
          <a href={`/${screenName}`}>
            <span className="ProfileCardStat-title">Tweets</span>
            <span>{user['~tweet.user'] ? user['~tweet.user'].length : 0}</span>
          </a>
        </Col>
        <Col xs={4}>
          <a href={`/${screenName}/following`}>
            <span className="ProfileCardStat-title">Following</span>
            <span>
              {user['user.friends'] ? user['user.friends'].length : 0}
            </span>
          </a>
        </Col>
        <Col xs={5}>
          <a href={`/${screenName}/followers`}>
            <span className="ProfileCardStat-title">Followers</span>
            <span>
              {user['~user.friends'] ? user['~user.friends'].length : 0}
            </span>
          </a>
        </Col>
      </Row>
    );
  }

  return content;
};

export default ProfileCardStats;
```

Instead of using passed props we explicitly use global state via the `useStateContext()` hook. But why not just pass props, since `ProfileCard` is just up one level in the component tree and could easily do so? The simple answer is better future-proofing. For example, if `ProfileCardStats` expects some props passed to it that contain `user` and `tweets` data what happens when we move this component to somewhere else in the app structure? We'd have to adjust the immediate parent component, at the very least, to pass the props, and in some cases the component tree may get extremely long, requiring a massive chain of passed props. It's for this very reason that the React team added context (i.e. global state), so we're making use of it here as well.

Thankfully, by leaning on the work of other components to update our global state, the `ProfileCardStats` component doesn't have to trigger any post-rendering effects -- it just grabs the data it needs and renders its UI.

We're also making heavy use of more reverse edges provided by Dgraph for `user` node predicates such as `~tweet.user` and `~user.friends`. These reverse edges retrieved from our query make it easy to determine the number of followers, friends, and tweets applicable to this user.

### User Components

#### Following and Followers

You may recall that the `Main.tsx` component contains a `<Switch>` rout to check for `/:screenName/followers` or `/:screenName/following` paths.

```tsx
Switch>
  <Route path={'/:screenName/followers'} component={Followers} />
  <Route path={'/:screenName/following'} component={Following} />
  <Route
    path={[
      '/',
      '/:screenName',
      '/search',
      '/:screenName/status/:tweetUid'
    ]}
    component={TweetList}
  />
</Switch>
```

The `Following` and `Followers` components extract the `:screenName` and retrieve the applicable user from the database. Here's the code for the `client/src/components/User/Following.tsx` component.

```tsx
// File: client/src/components/User/Following.tsx
// Components
import UserGrid from './UserGrid';
// Helpers
import config from '../../config';
import { useStateContext } from '../../state';
// Hooks
import { Action, ActionType } from '../../reducers/base';
import { useDgraphGlobal } from '../../hooks/dgraph';
// Libs
import { DgraphQueryExecutor, Queries } from 'dgraph-query-manager';
import React from 'react';

const Following = ({ match }) => {
  const [{ user }] = useStateContext();
  const screenName =
    match && match.params && match.params.screenName
      ? match.params.screenName
      : config.user.defaultAuthScreenName;

  const executorScreenName = new DgraphQueryExecutor(
    Queries.User.findFromScreenName,
    {
      $screenName: screenName,
    }
  );
  const [isScreenNameLoading, responseScreenName] = useDgraphGlobal({
    executor: executorScreenName,
    action: new Action(ActionType.SET_USER),
    // Re-render if match changes.
    dependencies: [screenName],
    // Invalid if screenName doesn't exist.
    invalid: !screenName,
  });
  const friends = user && user['user.friends'];

  return (
    <>
      <h1>Following</h1>
      <UserGrid users={friends} />
    </>
  );
};

export default Following;
```

We use the screen name to set the global `user` state and if that value exists we pass the `user['user.friends']` collection to the `UserGrid` component, which handles displaying a group of users in a flex grid.

#### UserGrid

The `UserGrid` component takes the passed `users` prop and splits the array into a collection of multi-dimensional arrays, each with a size equal to the `columnCount` constant.

```tsx
// File: client/src/components/User/UserGrid.tsx
// Components
import UserCard from './UserCard';
// Helpers
// Hooks
// Layout
import Row from 'react-bootstrap/es/Row';
// Libs
import React from 'react';

const UserGrid = ({ users }) => {
  const columnCount = 3;

  if (users) {
    // Split users into array of arrays equal to column count.
    const rows = [...Array(Math.ceil(users.length / columnCount))].map(
      (row, index) =>
        users.slice(index * columnCount, index * columnCount + columnCount)
    );
    return (
      <>
        {rows.map((row, index) => (
          <Row key={index}>
            {row.map(user => (
              <UserCard key={user.uid} user={user} />
            ))}
          </Row>
        ))}
      </>
    );
  } else {
    return <h3>No Users found.</h3>;
  }
};

export default UserGrid;
```

This takes advantage of our flex grid capabilities by splitting the full `users` array into sub-sets of `columnCount` number of users per `Row`. From there, each user is passed to the `UserCard` component, which handles actual user display.

#### UserCard

The `UserCard` component uses the passed `user` prop to create a `Card` element with basic user information such as the avatar and screen name.

```tsx
// File: client/src/components/User/UserCard.tsx
// Components
// Layout
import './UserCard.css';
import { Card, Image } from 'react-bootstrap';
// Libs
import React from 'react';

const UserCard = ({ user }) => {
  let content = <h3>Loading User</h3>;

  if (user) {
    const name = user['user.name'];
    const screenName = user['user.screenName'];

    content = (
      <Card className="UserCard col-sm-4">
        <Card.Body>
          <a href={`/${screenName}`} title={name}>
            <Image
              src={
                user['user.avatar']
                  ? user['user.avatar']
                  : 'https://www.gravatar.com/avatar/00000000000000000000000000000000'
              }
            />
          </a>
          <div>
            <div>
              <a href={`/${screenName}`}>{name}</a>
            </div>
            <span>
              <a href={`/${screenName}`}>
                <span>
                  @<b>{screenName}</b>
                </span>
              </a>
            </span>
          </div>
        </Card.Body>
      </Card>
    );
  } else {
    content = (
      <>
        <h3>No User found.</h3>
      </>
    );
  }
  return content;
};

export default UserCard;
```

With the combination of user components we've defined above we're able to navigate to a `/:screenName/followers` or `/:screenName/following` path and look at the collection of users that the `:screenName` user is respectively friends with or following.

![User Followers and Following](/images/followers-following.gif)

### Tweet Components

The last set of components to go over are those that handle tweets. It's generally a good idea to break functionality into smaller components whenever possible, so we have the `TweetList` component that contains a series of `TweetCard` components, which in turn contains a `Tweet` component. We also have the singular `TweetBox` component that the user uses to add new tweets. Finally, the `TweetModal` component which is used to simulate the singular modal view Twitter employs when viewing a specific tweet URL.

#### Tweet Box

Let's start by looking at the `TweetBox` [component](https://github.com/GabeStah/dgraph-twitter-clone/blob/master/client/src/components/Tweet/TweetBox.tsx), which is displayed at the top of the main content `Container` and allows the authenticated user to add new tweets.

```tsx
// File: client/src/components/Tweet/TweetBox.tsx
// Components
import { Button, Form } from 'react-bootstrap';
// Local
import { useStateContext } from '../../state';
// Libs
import React, { useState } from 'react';
import { Tweet } from 'dgraph-query-manager';
import { Action, ActionType } from '../../reducers/';

const TweetBox = () => {
  const [{ authUser, user, tweets }, dispatch] = useStateContext();

  const initialFormState = {
    'tweet.text': '',
    'tweet.user': authUser,
  };
  const [currentTweet, setCurrentTweet] = useState(initialFormState);

  const handleInputChange = event => {
    // Destructure textbox `id` and `value` fields.
    const { id, value } = event.target;
    // Update currentTweet params
    setCurrentTweet({ ...currentTweet, [id]: value });
  };

  const handleSubmit = async event => {
    event.preventDefault();
    // Checks for valid authUser and valid currentTweet text.
    if (
      !authUser ||
      !authUser.uid ||
      !currentTweet ||
      currentTweet['tweet.text'].length === 0
    ) {
      return;
    }

    const serialization = await Tweet.upsert({
      'tweet.text': currentTweet['tweet.text'],
      'tweet.user': authUser,
    });

    // Tweet created
    if (serialization.success) {
      setCurrentTweet(initialFormState);
      // Only update tweet list if authUser equals viewed user.
      if (user && user.uid.toString() === authUser.uid.toString()) {
        dispatch(
          new Action(ActionType.SET_TWEETS, [...tweets, serialization.response])
        );
      }
    }
  };

  return (
    <Form className={'TweetBox'} onSubmit={handleSubmit}>
      <Form.Group>
        <Form.Control
          id={'tweet.text'}
          as={'textarea'}
          type={'textarea'}
          value={currentTweet['tweet.text']}
          placeholder={"What's happening?"}
          onKeyDown={async event => {
            // On enter
            if (event.keyCode === 13) await handleSubmit(event);
          }}
          onChange={handleInputChange}
        />
        <Button variant={'primary'} type={'submit'}>
          Tweet
        </Button>
      </Form.Group>
    </Form>
  );
};

export default TweetBox;
```

There's a lot going on in the `TweetBox` component so we'll break it down into chunks. We start by grabbing the `authUser`, `user`, and `tweets` global state values, along with the `dispatch` function for later use. We then set the `currentTweet` local state to an object containing empty `tweet.text` and setting the `tweet.user` property to the `authUser`. This local `currentTweet` state can then be used to track changes to the tweet box input.

Let's skip down to the `return` render which is basically just a simple form with a `textarea` element and a submit button. Critically, we must set the `value` property of the textarea to the `currentTweet['tweet.text']` state value, otherwise React won't allow us to modify the text in the text box. The `onChange` event is handled by `handleInputChange()`, which uses the `setCurrentTweet()` function to set the local `currentTweet` state.

Meanwhile, the `onKeyDown` event checks if the **Enter** key was pressed, in which case it triggers submission, similar to the actual `onSubmit` form event.

The `handleSubmit()` function checks for a valid `authUser` and `currentTweet`, creates an object that matches properties of a `Partial<Tweet>` object, then passes those to the `Tweet.upsert()` method from the `dgraph-query-manager` package. If upsert was successful the tweet box is returned to its initial state. Finally, if the current `user` state matches the `authUser`, that means the `TweetList` component is displaying the list of tweets for the authorized user. In this case, we want to immediately update the `tweets` global state to reflect the new addition that was just upserted to the database, so we `dispatch()` the appropriate action and pass the new `tweets` list with the `serialization.response` (i.e. the created `Tweet` instance) added onto it.

{{% notice "warning" %}} It's worth pointing out that the logic of comparing the current `user` to the `authUser` should probably be refactored into a separate component or class, somewhere outside of `TweetBox`. It's kept here just because our simple app doesn't update that anywhere else, but a larger application would be wise to only allow the `TweetBox` to dispatch an action, while another section should actually determine what (if any) state data should be updated based on that. {{% /notice %}}

#### Tweet List

Our `TweetList` [component](https://github.com/GabeStah/dgraph-twitter-clone/blob/master/client/src/components/Tweet/TweetList.tsx) is short and sweet. It uses the `tweets` global state to render a list of `TweetCard` components.

```tsx
// File: client/src/components/Tweet/TweetList.tsx
// Components
import TweetCard from './TweetCard';
// Helpers
// Hooks
// Libs
import React from 'react';
import { useStateContext } from '../../state';

const TweetList = () => {
  const [{ tweets }] = useStateContext();
  let content;

  if (tweets && Array.isArray(tweets) && tweets.length > 0) {
    content = tweets.map(tweet => <TweetCard key={tweet.uid} tweet={tweet} />);
  } else if (tweets && !Array.isArray(tweets)) {
    content = <TweetCard key={tweets.uid} tweet={tweets} />;
  } else {
    content = <h3>No Tweets found.</h3>;
  }

  return content;
};

export default TweetList;
```

If the `tweets` state is defined then we pass every tweet in the collection to a new `TweetCard` component instance, along with setting the `key` property to a unique value and passing each `Tweet` as a prop.

#### Tweet Card

The `TweetCard` [component](https://github.com/GabeStah/dgraph-twitter-clone/blob/master/client/src/components/Tweet/TweetCard.tsx) provides most of the structure and layout to each tweet in the UI and contains logic for determining tweet-specific stats like the number of replies, retweets, favorites, and so forth.

```tsx
// File: client/src/components/Tweet/TweetCard.tsx
// Components
import Tweet from './Tweet';
// Layout
import './TweetCard.css';
import { Button, ButtonGroup, Card } from 'react-bootstrap';
// Libs
import React, { useEffect, useState } from 'react';
import { logger, numeral } from '../../helpers';
import {
  BaseModelDeletionMode,
  DgraphQueryExecutor,
  Queries,
  Uid,
  User,
} from 'dgraph-query-manager';
import * as _ from 'lodash';
// Font
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faRetweet } from '@fortawesome/free-solid-svg-icons';
import config from '../../config';
import { useStateContext } from '../../state';
import { Link } from 'react-router-dom';
import { Action, ActionType } from '../../reducers/base';

const TweetCard = ({ tweet }) => {
  const [{ authUser }, dispatch] = useStateContext();
  const [replies, setReplies]: [any, Function] = useState(undefined);
  const [, setIsLoading]: [boolean, Function] = useState(true);
  const [hasUserFavorited, setHasUserFavorited]: [boolean, Function] = useState(
    false
  );
  const [hasUserRetweeted, setHasUserRetweeted]: [boolean, Function] = useState(
    false
  );
  const [favoriteCount, setFavoriteCount]: [number, Function] = useState(0);
  const [retweetCount, setRetweetCount]: [number, Function] = useState(0);

  /**
   * Set replies.
   */
  useEffect(() => {
    if (!tweet) return;
    const params = {
      $id: tweet && tweet.uid ? tweet.uid.toString() : undefined,
    };
    const executor = new DgraphQueryExecutor(Queries.Tweet.getReplies, params);
    executor
      .execute()
      .then(serialization => {
        setIsLoading(false);
        if (serialization.success) {
          // Set replies to Array
          if (Array.isArray(serialization.response)) {
            setReplies(serialization.response);
          } else {
            setReplies(new Array(serialization.response));
          }
        }
      })
      .catch(exception => {
        logger.error(exception);
        setIsLoading(false);
      });
  }, [authUser, tweet]);

  useEffect(() => {
    if (!authUser || !authUser.uid || !tweet) return;

    const favorites = tweet['~user.favorites'];
    const retweets = tweet['~user.retweets'];

    setHasUserFavorited(
      _.isArray(favorites)
        ? _.some(
            favorites,
            other => other && other.uid === authUser.uid.toString()
          )
        : !!_.isObject(favorites)
    );
    setHasUserRetweeted(
      _.isArray(retweets)
        ? _.some(
            retweets,
            other => other && other.uid === authUser.uid.toString()
          )
        : !!_.isObject(retweets)
    );
    setFavoriteCount(
      _.isArray(favorites) ? favorites.length : _.isObject(favorites) ? 1 : 0
    );
    setRetweetCount(
      _.isArray(retweets) ? retweets.length : _.isObject(retweets) ? 1 : 0
    );
  }, [authUser, tweet]);

  /**
   * Check if currently authed User has replied to Tweet.
   */
  const hasAuthUserReplied = (): boolean => {
    if (!authUser || !replies || !authUser.uid) {
      return false;
    }
    return replies.some(reply => {
      if (authUser.uid && reply) {
        const replyUser = _.first(reply['tweet.user']);
        return (
          replyUser &&
          replyUser.uid &&
          replyUser.uid.toString() === authUser.uid.toString()
        );
      }
    });
  };

  /**
   * Toggle boolean field of Tweet.
   * @param property
   * @param event
   * @param enabled
   */
  const toggleBooleanField = async (
    property: string,
    event: any,
    enabled: any
  ) => {
    event.preventDefault();
    if (!tweet || !tweet.uid || !authUser || !authUser.uid) return;

    // Toggle current value.
    enabled = !enabled;
    if (enabled) {
      await User.insert({
        uid: new Uid(authUser.uid).toString(),
        [property]: {
          uid: new Uid(tweet.uid).toString(),
        },
      });
    } else {
      await User.delete(
        {
          uid: new Uid(authUser.uid).toString(),
          [property]: {
            uid: new Uid(tweet.uid).toString(),
          },
        },
        BaseModelDeletionMode.Raw
      );
    }

    dispatch(
      new Action(ActionType.TOGGLE_TWEET_PROPERTY, {
        isEnabled: enabled,
        // Reverse predicate for Tweets
        property: `~${property}`,
        tweet,
        user: authUser,
      })
    );
  };

  if (!tweet || !tweet.uid) return <></>;

  // Debug output Tweet Uid
  let debugElement;
  if (config.debug) {
    debugElement = <p>Uid: {tweet.uid.toString()}</p>;
  }

  return (
    <Card className="TweetCard">
      <Card.Body>
        <Tweet tweet={tweet} />
        <ButtonGroup>
          <Button
            className={'reply'}
            variant={'link'}
            active={hasAuthUserReplied()}
          >
            <FontAwesomeIcon icon={['far', 'comment']} />{' '}
            {numeral(replies ? replies.length : 0).format('0a')}
          </Button>
          <Button
            className={'retweet'}
            variant={'link'}
            active={hasUserRetweeted}
            onClick={e =>
              toggleBooleanField('user.retweets', e, hasUserRetweeted)
            }
          >
            <FontAwesomeIcon icon={faRetweet} />{' '}
            {numeral(retweetCount).format('0a')}
          </Button>
          <Button
            className={'favorite'}
            variant={'link'}
            active={hasUserFavorited}
            onClick={e =>
              toggleBooleanField('user.favorites', e, hasUserFavorited)
            }
          >
            <FontAwesomeIcon icon={['far', 'heart']} />{' '}
            {numeral(favoriteCount).format('0a')}
          </Button>
          <Button className={'dm'} variant={'link'}>
            <FontAwesomeIcon icon={['far', 'envelope']} />
          </Button>
          <Link
            to={{
              pathname: `/${
                _.isArray(tweet['tweet.user'])
                  ? _.first(tweet['tweet.user'])['user.screenName']
                  : tweet['tweet.user']['user.screenName']
              }/status/${tweet.uid.toString()}`,
            }}
          >
            <Button className={'details'} variant={'link'}>
              <FontAwesomeIcon icon={['far', 'arrow-alt-circle-right']} />{' '}
            </Button>
          </Link>
          {debugElement}
        </ButtonGroup>
      </Card.Body>
    </Card>
  );
};

export default TweetCard;
```

As we saw in the [Tweet List](#tweet-list) component the `TweetCard` component is one of the few components we are passing direct props to -- in this case, the `Tweet` instance to be displayed. The component logic starts with a few `useState()` hooks before the `useEffect()` hook that retrieves all replies to the current `Tweet`. This is a good example of how `useEffect()`, which occurs at least once after render, can be used for asynchronous data retrieval. Here we're using the `Tweet.getReplies` query which looks for tweet nodes in which `tweet.inReplyToStatusId` is set to the current `Tweet` `uid`. In other words, it finds all tweets that were replies to this one.

```js
query find($id: string) {
  data(func: has(tweet.text)) {
    tweets: @filter(uid_in(tweet.inReplyToStatusId, $id)) {
      uid
      expand(_all_) {
        uid
        expand(_all_)
      }
    }
  }
}
```

After executing the query we set the local `replies` state via the `setReplies` function.

The `hasAuthUserReplied()` function determines if the currently authorized user is among the set of users that replied to this tweet. Just like the actual Twitter, this value is used to change the highlighting on the `reply` `<Button>` element.

We've also specified a number of local state hooks to track and update the **favorite** and **retweet** status buttons. For example, within a `useEffect` hook we get the current `retweets` collection by getting the reverse edge values of `tweet['~user.retweets']`. We then call the `setHasUserRetweeted()` hook function and determine if the current authenticated user has retweeted the given tweet by checking for a matching `uid` within the `retweets` collection. We then use the `setRetweetCount()` hook function to set the retweet count. All of these local state values are used in the rendered JSX.

The `toggleBooleanField()` function is a helper that makes it possible for the user to toggle certain tweet flags when interacting with the UI. In this case, if the user wants to _favorite_ a tweet they click on the `favorite` `<Button>`, which triggers the `toggleBooleanField` function for the corresponding `user.favorites` property. Depending on what the newly-toggled value is we then await a `User.insert()` or `User.delete()` call, passing the `authUser.uid` as the primary uid and setting the passed `property` parameter equal to the secondary `tweet.uid` value. The `BaseModel.delete()` method provides helpers for performing advanced deletions via `BaseModelDeletionModes`, but in this case we're just passing raw JSON.

Here's an example of the kind of JSON that will be produced and sent to Dgraph.

```json
{
  "uid": "0x30ca9",
  "user.retweets": [
    {
      "uid": "0x31fa4"
    }
  ]
}
```

When performing an **insert** (i.e. a _mutation_) GraphQL+- will lookup the parent node by uid, which is the `User` node in this case. It will then add the secondary uid of the `Tweet` to the `user.retweets` edge collection. This is similar to how a relational database handles foreign key references.

On the flipside, when performing a **delete** GraphQL+- interprets the same JSON above as an indication that the matching secondary `Tweet` uid should be removed from the `user.retweets` edge collection of the parent `User` node.

The `toggleBooleanField()` function ends by dispatching a `TOGGLE_TWEET_PROPERTY` action, passing the relevant information like the tweet and user that are being toggled. Critically, we're also passing the _reverse_ edge of the predicate here. This is because the original predicate is tied to the `User` instance, but the `TOGGLE_TWEET_PROPERTY` reducer function modifies the `Tweet` instance.

```ts
case ActionType.TOGGLE_TWEET_PROPERTY: {
  const isEnabled = action.payload.isEnabled;
  const property = action.payload.property;
  const tweet = action.payload.tweet;
  const user = action.payload.user;

  const clone = _.clone(tweet);

  if (!_.has(clone, property)) {
    clone[property] = [];
  } else if (!_.isArray(clone[property])) {
    clone[property] = [clone[property]];
  }
  if (isEnabled) {
    clone[property].push(user);
  } else {
    clone[property] = _.reject(
      clone[property],
      other =>
        new Uid(other.uid).toString() === new Uid(user.uid).toString()
    );
  }

  return {
    ...state,
    tweets: _.map(state.tweets, original => {
      return original.uid.toString() === tweet.uid.toString()
        ? clone
        : original;
    })
  };
}
```

It's critical that reducers never mutate the state directly -- instead, they should only return updated state objects. Therefore, we start by cloning the `tweet` instance, then perform a couple checks to ensure we're dealing with an array. We then update the `Tweet` clone's property by either adding or removing the new `User` instance from the collection. Finally, the returned `state.tweets` object is a mapping containing all the existing tweets, except that we insert the modified clone.

The rendered HTML for the `TweetCard` is fairly self-explanatory. We're using some [FontAwesome](https://fontawesome.com/) icons for the buttons, but most of the component logic occurs in the functions above and the `useEffect()` hook we already explored. The `Tweet` component is also rendered at the top of this card and the current `tweet` value is passed as a prop to it.

#### Tweet

The `Tweet` [component](https://github.com/GabeStah/dgraph-twitter-clone/blob/master/client/src/components/Tweet/Tweet.tsx) displays the actual tweet text, #hashtags, @mentions, the user info, and the creation timestamp.

```tsx
// File: client/src/components/Tweet/Tweet.tsx
// Layout
import './Tweet.css';
import { Image } from 'react-bootstrap';
// Libs
import moment from 'moment';
import React from 'react';
import * as twitter from 'twitter-text';
import ReactHtmlParser from 'react-html-parser';

const Tweet = props => {
  const tweet = props.tweet;
  const user = tweet['tweet.user'];
  const name = user['user.name'];
  const screenName = user['user.screenName'];

  const tweetLinks = twitter.autoLink(tweet['tweet.text'], {
    hashtagUrlBase: '/search?q=%23',
    listUrlBase: '/',
    usernameUrlBase: '/',
  });

  return (
    <>
      <div className={'tweet-header'}>
        <ul>
          <li>
            <a href={`/${screenName}`} title={name}>
              <Image
                className={'avatar'}
                src={user && user['user.avatar'] ? user['user.avatar'] : ''}
              />
            </a>
          </li>
          <li>
            <span>
              <a href={`/${screenName}`}>
                <b>{name}</b>
              </a>
            </span>
          </li>
          <li>
            <a href={`/${screenName}`}>
              <span>@{screenName}</span>
            </a>
          </li>
          <li>
            <span className={'createdAt'}>
              {moment(tweet['tweet.createdAt']).fromNow()}
            </span>
          </li>
        </ul>
      </div>
      <div className={'tweet'}>
        <p>{ReactHtmlParser(tweetLinks)}</p>
      </div>
    </>
  );
};

export default Tweet;
```

We're using the [Twitter Text](https://github.com/twitter/twitter-text/) library provided by Twitter to help with parsing the tweet text. In this case, the [`autoLink()`](https://github.com/twitter/twitter-text/blob/master/js/src/autoLink.js) function detects where entities like hashtags and mentions are within the tweet, and surrounds those elements with appropriate `<a>` tags. By passing some extra options to the function call we can override the defaults so our search URL is local, rather than linking to `twitter.com`.

#### Tweet Modal

The final tweet component to look at is the `TweetModal` component. As the name suggests, this component creates a modal popup overlay that contains a single `Tweet`. As such, it illustrates the power of reusable components, since it renders the `TweetCard` (which itself renders the `Tweet` component).

```tsx
// File: client/src/components/Tweet/TweetModal.tsx
import React, { useEffect, useState } from 'react';
import { Button, Modal } from 'react-bootstrap';
import { DgraphQueryExecutor, Queries } from 'dgraph-query-manager';
import TweetCard from './TweetCard';
import { useStateContext } from '../../state';
import * as _ from 'lodash';
import { logger } from '../../helpers/logger';

const TweetModal = ({ match }) => {
  const [{ tweets }] = useStateContext();
  const [isShowing, setIsShowing] = useState(true);
  const [uid, setUid] = useState(undefined);
  const [tweet, setTweet] = useState(undefined);
  const passedUid = match.params.tweetUid;

  // Update when passed Uid differs from state.
  if (uid !== passedUid) {
    setIsShowing(true);
    setUid(passedUid);
  }

  const onHide = () => {
    setIsShowing(false);
  };

  useEffect(() => {
    // Attempt to retrieve Tweet from local state collection.
    setTweet(_.find(tweets, obj => obj.uid.toString() === uid));
    const executor = new DgraphQueryExecutor(Queries.Tweet.find, {
      $id: uid,
    });
    // If Tweet not in state, retrieve from database.
    if (!tweet) {
      executor
        .execute()
        .then(serialization => {
          if (serialization.success) {
            setTweet(serialization.response);
          }
        })
        .catch(exception => {
          logger.error(exception);
        });
    }
  }, [tweet, tweets, uid]);

  return (
    <Modal show={isShowing} onHide={onHide}>
      <Modal.Header closeButton />
      <Modal.Body>
        <TweetCard tweet={tweet} />
      </Modal.Body>
      <Modal.Footer>
        <Button onClick={onHide}>Close</Button>
      </Modal.Footer>
    </Modal>
  );
};

export default TweetModal;
```

As you may recall from the [Routing with React Router DOM](#routing-with-react-router-dom) section, the `Main` component contains a `Route` that references the `TweetModal` component.

```tsx
<Route path={'/status/:tweetUid'} component={TweetModal} />
```

This routeing path mimics the path that Twitter uses for singular tweet URLs, so the `TweetModal` component will only render when the user is looking at a single tweet.

The logic we're using here is to grab the `tweetUid` param from the `match` object provided by `react-router-dom` and set it to local `uid` state. From there a new `DgraphQueryExecutor` is passed that tweet's `uid` and it uses the `Tweet.find` `Query` to see if the `uid` exists in the Dgraph database. Here's what that query looks like.

```js
query find($id: string) {
  data(func: uid($id)) {
    uid
    expand(_all_) {
      uid
      expand(_all_)
    }
  }
}
```

In the event that a response is provided the modal is set to show and the retrieved `Tweet` instance is passed as a prop to the rendered `TweetCard` component, which behaves just as we saw above.

It's worth noting that we're using the `useDgraphLocal()` [custom hook](https://github.com/GabeStah/dgraph-twitter-clone/blob/master/client/src/hooks/dgraph/useDgraphLocal.ts) here, which is somewhat similar to the `useDgraphGlobal()` hook, with the major difference being it stores state locally, not globally.

```ts
// File: client/src/hooks/dgraph/useDgraphLocal.ts
// Helpers
import { logger } from '../../helpers';
// Libs
import { useEffect, useState } from 'react';
import { DgraphQueryExecutor } from 'dgraph-query-manager';

/**
 * Custom React hook that performs the heavy lifting of data retrieval
 * from Dgraph and uses local state.  Accepts a DgraphQueryExecutor that is
 * executed, the response of which is assigned to state.
 *
 * @param parameters.executor Executor to be executed.
 * @param parameters.dependencies Values that will trigger a re-render upon change.
 * @param parameters.allowFailure Allows failed result to still be dispatched to state.
 */
export const useDgraphLocal = (parameters: {
  executor: DgraphQueryExecutor;
  dependencies: any;
  allowFailure?: boolean;
}): [boolean, any] => {
  const { executor, dependencies, allowFailure = false } = parameters;
  const [isLoading, setIsLoading]: [boolean, Function] = useState(true);
  const [response, setResponse]: [any, Function] = useState(undefined);

  useEffect(() => {
    setIsLoading(true);
    executor
      .execute()
      .then(serialization => {
        setIsLoading(false);
        if (serialization.success || allowFailure) {
          setResponse(serialization.response);
        }
      })
      .catch(exception => {
        logger.error(exception);
        setIsLoading(false);
      });
  }, dependencies);

  return [isLoading, response];
};
```

Other than that, it behaves much the same, allowing the `TweetModal` component to perform a post-render effect to asynchronously retrieve Dgraph data and use the response for further processing.

### Next Steps

Whew! That was quite a lot to cover throughout this guide, but hopefully, this series helped to illustrate how any type of app -- from this relatively simple `dgraph-twitter-clone` to a large-scale, distributed system -- can realize significant benefits by integrating with a graph database like Dgraph.

In [The Architecture - Schema]({{% ref "/#schema" %}}) we explored how Dgraph's schema specification makes it easy to design complex data structures _without_ the need to define (or even know about) explicit relationships. This flexibility allows your data layer to be dynamically expanded and mutate to the needs of the application over time. In fact, Dgraph has no problem accepting data with unknown predicates and automatically adding them to the schema for future use! Check out the [Schema documentation](https://docs.dgraph.io/query-language/#schema) for more details.

In the [Search Component](#search-component) section we also explored how Dgraph's GraphQL+- makes it easy to execute performant joins and reverse joins across any shape of data. With features like [reverse edges](https://docs.dgraph.io/query-language/#reverse-edges), [powerful indexing](https://docs.dgraph.io/query-language/#indexing), [filter logic](https://docs.dgraph.io/query-language/#connecting-filters), [query](https://docs.dgraph.io/query-language/#query-variables) and [value](https://docs.dgraph.io/query-language/#value-variables) variables, [GroupBy](https://docs.dgraph.io/query-language/#groupby), and much more, Dgraph eliminates many of the potential headaches found when trying to perform complex joins across large datasets within traditional SQL-like databases. Head over to the [Query Language](https://docs.dgraph.io/query-language/) documentation to get tons more info on GraphQL+- and how it can streamline your data layer.

There's plenty more to learn about how Dgraph can benefit your team and your next project, so check out some of the [benefits](https://dgraph.io/), see how to [get started](https://docs.dgraph.io/get-started/), take our [interactive tour](https://tour.dgraph.io/), chat with us on our [discussion forums](https://discuss.dgraph.io/), or even throw us a [star on GitHub](https://github.com/dgraph-io/dgraph) if you're so inclined. If you're ready to get more direct support and see how Dgraph engineers can help you, check out our [Startup and Enterprise Support](https://dgraph.io/support) plans or [get in touch](mailto:contact@dgraph.io?subject=I%20would%20like%20to%20sign%20up%20for%20the%20Enterprise%20Package) directly.
