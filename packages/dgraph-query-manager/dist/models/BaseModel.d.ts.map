{"version":3,"sources":["../packages/dgraph-query-manager/src/models/BaseModel.ts"],"names":[],"mappings":"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","file":"BaseModel.d.ts","sourcesContent":["// tslint:disable:no-null-keyword\r\nimport logger from '../logger';\r\nimport { DgraphAdapterHttp as DgraphAdapter, MutationTypes } from '../adapters';\r\nimport { DgraphQueryExecutor, Queries, Serialization } from '../classes';\r\nimport { Hashtag, Tweet, Uid, UidParamsType, User } from '../models';\r\n\r\n/**\r\n * All - Deletes the node and all child nodes.\r\n * Node - Deletes node.\r\n * Edge - Deletes specified edge(s).\r\n * AllChildEdges - Removes all child edges from node.\r\n * AllChildNodes - Deletes all child nodes and edge references from node.\r\n */\r\nexport enum BaseModelDeletionMode {\r\n  All,\r\n  Node,\r\n  Edge,\r\n  AllChildEdges,\r\n  AllChildNodes\r\n}\r\n\r\nexport type BaseModelNodeableTypes = Hashtag | Tweet | User;\r\n\r\nexport interface BaseModelInterface {\r\n  uid?: Uid;\r\n}\r\n\r\nexport class BaseModel<T> implements BaseModelInterface {\r\n  uid?: Uid;\r\n\r\n  /**\r\n   * Constructs an instance of inheriting class using an (optional) partial parameters object.\r\n   * @param {Partial<BaseModel<T>>} params\r\n   * @param uid\r\n   */\r\n  constructor(params: Partial<BaseModel<T>> = {}, uid?: UidParamsType) {\r\n    Object.assign(this, params);\r\n    if (this.uid) {\r\n      this.uid = new Uid(this.uid);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Factory that creates BaseModel instances from Partial<BaseModel<T>> paramTypes.\r\n   * @param {Partial<BaseModel<T>>} params\r\n   * @returns {Promise<BaseModel<T>>}\r\n   */\r\n  static async create<T extends typeof BaseModel>(\r\n    params: Partial<BaseModel<T>>\r\n  ): Promise<Serialization> {\r\n    const className = this.name;\r\n    const serialization = new Serialization({\r\n      message: `${className} successfully created.`,\r\n      data: params,\r\n      request: params\r\n    });\r\n    return new Promise((resolve, reject) => {\r\n      this.load(params)\r\n        .then(processed => {\r\n          // logger.info(\r\n          //   `${className}.create.load.then fulfilled, processed: %o`,\r\n          //   processed\r\n          // );\r\n          serialization.response = new this(processed);\r\n          serialization.success = true;\r\n          resolve(serialization);\r\n        })\r\n        .catch(error => {\r\n          logger.info(\r\n            `${className}.create.load.then failed, error: %o', error`\r\n          );\r\n          serialization.error = error;\r\n          serialization.message = `${className} creation failed.`;\r\n          serialization.success = false;\r\n          resolve(serialization);\r\n        });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Factory that creates multiple BaseModel instances from BaseModel array.\r\n   * @param {Partial<BaseModel<T>>[]} params\r\n   * @returns {Promise<BaseModel<T>[]>}\r\n   */\r\n  static async createMany<T extends typeof BaseModel>(\r\n    params: Partial<BaseModel<T>>[] = []\r\n  ): Promise<BaseModel<T>[]> {\r\n    const elements: any[] = [];\r\n    for await (const param of params) {\r\n      elements.push((await this.create(param)).response);\r\n    }\r\n    return elements;\r\n  }\r\n\r\n  /**\r\n   * Delete nodes, edges, or children of passed object.\r\n   * @param {Uid | BaseModel<T> | object | string} item\r\n   * @param {BaseModelDeletionMode} mode\r\n   * @param {string} edge\r\n   * @returns {Promise<Serialization>}\r\n   */\r\n  static async delete<T extends typeof BaseModel>(\r\n    this: T,\r\n    item: Uid | BaseModel<T> | object | string,\r\n    mode: BaseModelDeletionMode = BaseModelDeletionMode.All,\r\n    edge?: string\r\n  ): Promise<Serialization> {\r\n    const adapter = new DgraphAdapter();\r\n    const className = this.name;\r\n    let serialization = new Serialization({\r\n      message: `${className} successfully deleted.`,\r\n      data: item\r\n    });\r\n    if (\r\n      item instanceof BaseModel ||\r\n      (typeof item === 'object' && !(item instanceof Uid))\r\n    ) {\r\n      serialization.request = this.getDeletionRequest(item, mode, edge);\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      adapter\r\n        .mutate(serialization, MutationTypes.DeleteJson)\r\n        .then(result => {\r\n          serialization = result;\r\n          serialization.success = true;\r\n          resolve(serialization);\r\n        })\r\n        .catch(error => {\r\n          serialization.error = error;\r\n          serialization.statusCode = 500;\r\n          serialization.success = false;\r\n          serialization.message = `${className} deletion failed.`;\r\n          reject(serialization);\r\n        });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Deserialize Dgraph object.\r\n   * @param {Partial<any | T>} params\r\n   * @returns {Promise<Partial<T>>}\r\n   */\r\n  static deserialize<T>(params: Partial<T | any> = {}): Partial<T> {\r\n    // Update Uid\r\n    if (params.uid) {\r\n      if (Array.isArray(params.uid)) {\r\n        // Assume first Uid is applicable\r\n        params.uid = new Uid(params.uid[0]);\r\n      } else {\r\n        params.uid = new Uid(params.uid);\r\n      }\r\n    }\r\n    return params;\r\n  }\r\n\r\n  /**\r\n   * Find a node in database based on passed Uid or BaseModel<T> instance type.\r\n   * @param {BaseModel<T> | Uid | string | number} params\r\n   * @returns {Promise<Serialization>}\r\n   */\r\n  static async find<T extends typeof BaseModel>(\r\n    this: T,\r\n    params: BaseModel<T> | Uid | string | number\r\n  ): Promise<Serialization> {\r\n    // const adapter = new DgraphAdapter();\r\n    const className = this.name;\r\n    let uid = '';\r\n\r\n    // Get uid string from Uid instance.\r\n    if (params instanceof this && params.uid) {\r\n      uid = params.uid.toString();\r\n    } else if (params instanceof Uid) {\r\n      uid = params.toString();\r\n    }\r\n\r\n    const executor = new DgraphQueryExecutor(Queries[className].find, {\r\n      $id: uid\r\n    });\r\n    const serialization = await executor.execute();\r\n    if (serialization && serialization.success && serialization.response) {\r\n      // Create instance of T from deserialized result.\r\n      serialization.response = new this(serialization.response) as InstanceType<\r\n        T\r\n      >;\r\n    }\r\n    return serialization;\r\n  }\r\n\r\n  /**\r\n   * Find this node in database.\r\n   * @returns {Promise<Serialization>}\r\n   */\r\n  async find<T>(): Promise<Serialization> {\r\n    const adapter = new DgraphAdapter();\r\n    const className = this.constructor.name;\r\n    const serialization = new Serialization({\r\n      message: `${className} found.`\r\n    });\r\n\r\n    return new Promise((resolve, reject) => {\r\n      adapter\r\n        .query(serialization)\r\n        .then(payload => {\r\n          serialization.data = payload;\r\n          serialization.response = payload;\r\n          serialization.success = true;\r\n          resolve(serialization);\r\n        })\r\n        .catch(error => {\r\n          serialization.data = this;\r\n          serialization.statusCode = 500;\r\n          serialization.success = false;\r\n          serialization.message = `${className} find failed.`;\r\n          reject(serialization);\r\n        });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Converts passed JSON string or object to new inheriting class instance.\r\n   * @param {object | string} json\r\n   * @returns {InstanceType<T>}\r\n   */\r\n  static fromJSON<T extends typeof BaseModel>(\r\n    this: T,\r\n    json: object | string\r\n  ): InstanceType<T> {\r\n    switch (typeof json) {\r\n      case 'object':\r\n        return Object.assign(new this() as InstanceType<T>, json);\r\n      case 'string':\r\n        return Object.assign(new this() as InstanceType<T>, JSON.parse(json));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Converts passed object to new inheriting calss instance.\r\n   * @param {object} obj\r\n   * @returns {InstanceType<T>}\r\n   */\r\n  fromObject<T extends typeof BaseModel>(\r\n    this: T,\r\n    obj: object\r\n  ): InstanceType<T> {\r\n    return Object.assign(new this() as InstanceType<T>, obj);\r\n  }\r\n\r\n  /**\r\n   * Generates a deletion request object based on passed object and paramTypes.\r\n   * @param {BaseModel<T> | any} params\r\n   * @param {BaseModelDeletionMode} mode\r\n   * @param {string} edge\r\n   * @returns {object | undefined}\r\n   */\r\n  static getDeletionRequest<T extends typeof BaseModel>(\r\n    params: BaseModel<T> | any,\r\n    mode: BaseModelDeletionMode = BaseModelDeletionMode.All,\r\n    edge?: string\r\n  ): object | undefined {\r\n    let result: any = [];\r\n    // Add primary Uid\r\n    if (params.hasOwnProperty('uid') && params.uid) {\r\n      result.push({\r\n        uid: params.uid.toString()\r\n      });\r\n    }\r\n\r\n    if (mode === BaseModelDeletionMode.All) {\r\n      // Add parent node Uid to uids list.\r\n      Object.entries(params).forEach(([key, value]) => {\r\n        // Check if deletable\r\n        if (value instanceof BaseModel && value.isDeletableType()) {\r\n          // Add Uid to list to delete actual child node\r\n          result.push(new Uid(value));\r\n        } else if (\r\n          Array.isArray(value) &&\r\n          value.some(\r\n            element => element instanceof BaseModel && element.isDeletableType()\r\n          )\r\n        ) {\r\n          // Add array of node Uids to uids list\r\n          result = result.concat(\r\n            value\r\n              .filter(parent => parent.isDeletableType())\r\n              .map(child => new Uid(child))\r\n          );\r\n        }\r\n      });\r\n    } else if (mode === BaseModelDeletionMode.AllChildNodes) {\r\n      Object.entries(params).forEach(([key, value]) => {\r\n        // Check if deletable\r\n        if (value instanceof BaseModel && value.isDeletableType()) {\r\n          // Null key of child type to remove edge reference\r\n          result[0][key] = null;\r\n          // Add Uid to list to delete actual child node\r\n          result.push(new Uid(value));\r\n        } else if (\r\n          Array.isArray(value) &&\r\n          value.some(\r\n            element => element instanceof BaseModel && element.isDeletableType()\r\n          )\r\n        ) {\r\n          // Null key of child type to remove edge reference\r\n          result[0][key] = null;\r\n          // Add array of node Uids to uids list\r\n          result = result.concat(\r\n            value\r\n              .filter(parent => parent.isDeletableType())\r\n              .map(child => new Uid(child))\r\n          );\r\n        }\r\n      });\r\n    } else if (mode === BaseModelDeletionMode.AllChildEdges) {\r\n      Object.entries(params).forEach(([key, value]) => {\r\n        // Check if deletable\r\n        if (value instanceof BaseModel && value.isDeletableType()) {\r\n          // Null key of child type to remove edge reference\r\n          result[0][key] = null;\r\n        } else if (\r\n          Array.isArray(value) &&\r\n          value.some(\r\n            element => element instanceof BaseModel && element.isDeletableType()\r\n          )\r\n        ) {\r\n          result[0][key] = null;\r\n        }\r\n      });\r\n    } else if (mode === BaseModelDeletionMode.Edge) {\r\n      let count = 0;\r\n      if (edge) {\r\n        Object.entries(params).forEach(([key, value]) => {\r\n          if (key === edge) {\r\n            // Check if deletable\r\n            if (value instanceof BaseModel && value.isDeletableType()) {\r\n              // Null key of child type to remove edge reference\r\n              result[0][key] = null;\r\n              count++;\r\n            } else if (\r\n              Array.isArray(value) &&\r\n              value.some(\r\n                element =>\r\n                  element instanceof BaseModel && element.isDeletableType()\r\n              )\r\n            ) {\r\n              result[0][key] = null;\r\n              count++;\r\n            }\r\n          }\r\n        });\r\n      }\r\n      // No matching edges found.\r\n      if (count === 0) {\r\n        throw new Error(\r\n          `Cannot delete edge (${edge}) of object: ${JSON.stringify(params)}`\r\n        );\r\n      }\r\n    }\r\n\r\n    // GRPC won't accept a single-element Array, so return first element object if singular.\r\n    return result.length === 1 ? result[0] : result;\r\n  }\r\n\r\n  /**\r\n   * Generates temporary instance of T and returns object containing combined default properties with passes paramTypes.\r\n   * @param {Partial<T>} params\r\n   * @returns {InstanceType<T>}\r\n   */\r\n  static injectDefaults<T extends typeof BaseModel>(\r\n    this: T,\r\n    params: Partial<T> = {}\r\n  ): InstanceType<T> {\r\n    const temp = new this() as InstanceType<T>;\r\n    return { ...temp, ...params };\r\n  }\r\n\r\n  /**\r\n   * Directly insert object into database.\r\n   * @param {Partial<T>} params\r\n   * @param {Partial<T> | object} params2\r\n   * @returns {Promise<Serialization>}\r\n   */\r\n  static async insert<T>(\r\n    params: Partial<T> = {},\r\n    params2?: Partial<T> | object\r\n  ): Promise<Serialization> {\r\n    Object.assign(params, params2);\r\n    const adapter = new DgraphAdapter();\r\n    const className = this.name;\r\n    const serialization = new Serialization({\r\n      message: `${className} created.`,\r\n      request: params,\r\n      data: params\r\n    });\r\n\r\n    return new Promise((resolve, reject) => {\r\n      adapter\r\n        .mutate(serialization)\r\n        .then(serialization => {\r\n          // serialization.response = payload;\r\n          serialization.success = true;\r\n          resolve(serialization);\r\n        })\r\n        .catch(error => {\r\n          // serialization.data = paramTypes;\r\n          serialization.statusCode = 500;\r\n          serialization.success = false;\r\n          serialization.error = error;\r\n          serialization.message = `${className} creation failed.`;\r\n          reject(serialization);\r\n        });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Indicates if instance is a deletable type.\r\n   * @returns {boolean}\r\n   */\r\n  isDeletableType(): boolean {\r\n    const className = this.constructor.name;\r\n    return className === 'Hashtag' || className === 'Tweet';\r\n  }\r\n\r\n  /**\r\n   * Indicates if passed in value is a deletable type.\r\n   * @param obj\r\n   * @returns {boolean}\r\n   */\r\n  static isDeletableType(obj: any): boolean {\r\n    const className = obj.constructor.name;\r\n    return className === 'Hashtag' || className === 'Tweet';\r\n  }\r\n\r\n  /**\r\n   * Indicates if instance is a nodeable type (i.e. can have a Uid in database).\r\n   * @returns {boolean}\r\n   */\r\n  isNodeableType(): boolean {\r\n    const className = this.constructor.name;\r\n    return (\r\n      className === 'Hashtag' || className === 'Tweet' || className === 'User'\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Indicates if passed in value is a nodeable type (i.e. can have a Uid in database).\r\n   * @param obj\r\n   * @returns {boolean}\r\n   */\r\n  static isNodeableType(obj: any): boolean {\r\n    const className = obj.constructor.name;\r\n    return (\r\n      className === 'Hashtag' || className === 'Tweet' || className === 'User'\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Determines if passed payload object is valid.\r\n   * @param {object} response\r\n   * @returns {boolean}\r\n   */\r\n  static isResponseValid<T extends typeof BaseModel>(\r\n    this: T,\r\n    response: object\r\n  ): boolean {\r\n    const className = this.name;\r\n    return !!(typeof response === 'object' && response[className]);\r\n  }\r\n\r\n  /**\r\n   * Invokes async BaseModel<T> creation process.\r\n   * @param {Partial<BaseModel<T>>} params\r\n   * @returns {Promise<Partial<BaseModel<T>>>}\r\n   */\r\n  static async load<T>(\r\n    params: Partial<BaseModel<T>> = {}\r\n  ): Promise<Partial<BaseModel<T>>> {\r\n    // Combine paramTypes with default properties.\r\n    params = this.injectDefaults(params);\r\n    return params;\r\n  }\r\n\r\n  /**\r\n   * Serialize object into Dgraph acceptable format for JSON transaction.\r\n   * @param {Partial<any | T>} params\r\n   * @returns {Promise<Partial<T>>}\r\n   */\r\n  static async serialize<T>(\r\n    params: Partial<T | any> = {}\r\n  ): Promise<Partial<T>> {\r\n    const serialization: any = {};\r\n    // Update Uid\r\n    if (params.uid) {\r\n      if (Array.isArray(params.uid)) {\r\n        // Assume first Uid is applicable\r\n        params.uid = new Uid(params.uid[0]);\r\n      } else {\r\n        params.uid = new Uid(params.uid);\r\n      }\r\n    }\r\n    for await (const key of Object.keys(params)) {\r\n      // Check if Uid\r\n      if (params[key] instanceof Uid && key === 'uid') {\r\n        // Convert Uid to string values\r\n        serialization[key] = params[key].toString();\r\n      } else if (params[key] instanceof BaseModel) {\r\n        // For BaseModel instances recursively serialize\r\n        serialization[key] = await this.serialize(params[key]);\r\n      } else if (\r\n        Array.isArray(params[key]) &&\r\n        params[key].filter(instance => instance instanceof BaseModel).length > 0\r\n      ) {\r\n        const instances: any[] = [];\r\n        for await (const instance of params[key]) {\r\n          instances.push(await this.serialize(instance));\r\n        }\r\n        serialization[key] = instances;\r\n      } else {\r\n        serialization[key] = params[key];\r\n      }\r\n    }\r\n    return serialization;\r\n  }\r\n\r\n  /**\r\n   * Converts class instance to JSON string.\r\n   * REMOVED: Removed due to incompatibility with GRPC (GRPC unintentionally calls this method).\r\n   * @returns {string}\r\n   */\r\n  // toJSON<T>(this: T): string {\r\n  //     const temp = JSON.stringify(Object.assign({}, this));\r\n  //     return temp;\r\n  // }\r\n\r\n  /**\r\n   * Converts class instance to JavaScript object.\r\n   * @returns {T}\r\n   */\r\n  toObject<T>(this: T): T {\r\n    return Object.assign({}, this);\r\n  }\r\n\r\n  /**\r\n   * TODO: Convert instance to query.\r\n   * @returns {string}\r\n   */\r\n  toQuery(): string {\r\n    return '';\r\n  }\r\n\r\n  /**\r\n   * Create database node of instance if matching Uid doesn't exist.\r\n   * If Uid exists, update node instead.\r\n   * @param {Partial<T>} params\r\n   * @param {Partial<T> | object} params2\r\n   * @returns {Promise<Serialization>}\r\n   */\r\n  static async upsert<T>(\r\n    params: Partial<T> = {},\r\n    params2?: Partial<T> | object\r\n  ): Promise<Serialization> {\r\n    Object.assign(params, params2);\r\n    const className = this.name;\r\n    const serialization = new Serialization({\r\n      message: `${className} upserted.`,\r\n      data: params,\r\n      request: params\r\n    });\r\n\r\n    return new Promise((resolve, reject) => {\r\n      this.load(params)\r\n        .then(payload => {\r\n          serialization.response = new this(payload);\r\n          serialization.success = true;\r\n          resolve(serialization);\r\n        })\r\n        .catch(error => {\r\n          // serialization.data = this;\r\n          serialization.error = error;\r\n          serialization.statusCode = 500;\r\n          serialization.success = false;\r\n          serialization.message = `${className} upsert failed.`;\r\n          reject(serialization);\r\n        });\r\n    });\r\n  }\r\n}\r\n"]}