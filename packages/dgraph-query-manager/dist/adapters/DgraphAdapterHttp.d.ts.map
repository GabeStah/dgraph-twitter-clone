{"version":3,"sources":["../packages/dgraph-query-manager/src/adapters/DgraphAdapterHttp.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,YAAY,EAAE,gBAAgB,EAAE,MAAM,gBAAgB,CAAC;AAIhE,OAAO,EAAE,aAAa,EAAE,MAAM,iBAAiB,CAAC;AAChD,OAAO,EAAE,aAAa,EAAE,MAAM,YAAY,CAAC;AAE3C,qBAAa,iBAAiB;IAC5B;;OAEG;IACH,OAAO,MAAiC;IAExC;;OAEG;IACH,SAAS,CAAC,MAAM,EAAE,WAAW,CAAC,YAAY,CAAC,CAAC;IAE5C;;OAEG;IACH,SAAS,CAAC,UAAU,EAAE,WAAW,CAAC,gBAAgB,CAAC,CAAC;gBAExC,OAAO,CAAC,EAAE,MAAM;IAM5B;;;;OAIG;IACG,WAAW,CAAC,MAAM,EAAE,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC;IAanD;;;OAGG;IACG,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC;IAcjC;;;;;OAKG;IACH,MAAM,CAAC,aAAa,CAAC,GAAG,EAAE,GAAG;IAuB7B,MAAM,CAAC,qBAAqB,CAAC,GAAG,KAAA;IAoBhC;;;;;;;OAOG;IACG,MAAM,CAAC,CAAC,EACZ,aAAa,EAAE,aAAa,EAC5B,YAAY,GAAE,aAAqC,EACnD,SAAS,UAAQ,GAChB,OAAO,CAAC,aAAa,CAAC;IA4CzB;;;;OAIG;IACG,KAAK,CAAC,CAAC,EAAE,aAAa,EAAE,aAAa,GAAG,OAAO,CAAC,aAAa,CAAC;IAapE;;;;;OAKG;IACG,aAAa,CACjB,aAAa,EAAE,aAAa,EAC5B,IAAI,CAAC,EAAE,GAAG,GACT,OAAO,CAAC,aAAa,CAAC;CAiB1B","file":"DgraphAdapterHttp.d.ts","sourcesContent":["// Lib\r\nimport { DgraphClient, DgraphClientStub } from 'dgraph-js-http';\r\n// Local\r\nimport config from '../config';\r\nimport logger from '../logger'\r\nimport { MutationTypes } from './MutationTypes';\r\nimport { Serialization } from '../classes';\r\n\r\nexport class DgraphAdapterHttp {\r\n  /**\r\n   * Endpoint address of Dgraph server.\r\n   */\r\n  address = config.dgraph.adapter.address;\r\n\r\n  /**\r\n   * Dgraph client.\r\n   */\r\n  protected client: NonNullable<DgraphClient>;\r\n\r\n  /**\r\n   * Dgraph client stub.\r\n   */\r\n  protected clientStub: NonNullable<DgraphClientStub>;\r\n\r\n  constructor(address?: string) {\r\n    if (address) this.address = address;\r\n    this.clientStub = new DgraphClientStub(this.address);\r\n    this.client = new DgraphClient(this.clientStub);\r\n  }\r\n\r\n  /**\r\n   * Alter the database schema.\r\n   * @param {string} schema\r\n   * @returns {Promise<boolean>}\r\n   */\r\n  async alterSchema(schema: string): Promise<boolean> {\r\n    return this.client\r\n      .alter({ schema })\r\n      .then(() => {\r\n        logger.info(`Dgraph schema altered: %s`, schema);\r\n        return true;\r\n      })\r\n      .catch(error => {\r\n        logger.error(`Dgraph schema alteration failed, error: %s`, error);\r\n        return false;\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Drop all database data.\r\n   * @returns {Promise<boolean>}\r\n   */\r\n  async dropAll(): Promise<boolean> {\r\n    const result = await this.client\r\n      .alter({ dropAll: true })\r\n      .then(() => {\r\n        logger.info(`All Dgraph data dropped.`);\r\n        return true;\r\n      })\r\n      .catch(error => {\r\n        logger.error(`Dgraph data drop failed, error: %s`, error);\r\n        return false;\r\n      });\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Recursively flattens arrays within passed object.\r\n   * Sets object key value pointing to a single-element array to value of that only element.\r\n   * @param {object} obj\r\n   * @returns {any}\r\n   */\r\n  static flattenArrays(obj: any) {\r\n    const copy: any = obj;\r\n    if (Array.isArray(obj)) {\r\n      obj.forEach((value, key) => {\r\n        if (Array.isArray(value) && value.length === 1) {\r\n          // Set keyvalue to first (and only) array value.\r\n          copy[key] = DgraphAdapterHttp.flattenArrays(value[0]);\r\n        }\r\n      });\r\n    } else {\r\n      for (const key in obj) {\r\n        if (obj.hasOwnProperty(key)) {\r\n          if (Array.isArray(obj[key]) && obj[key].length === 1) {\r\n            // Set keyvalue to first (and only) array value.\r\n            copy[key] = DgraphAdapterHttp.flattenArrays(obj[key][0]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return copy;\r\n  }\r\n\r\n  static flattenArraysInObject(obj) {\r\n    const copy: any = obj;\r\n    Object.entries(obj).forEach(([key, value]) => {\r\n      if (obj.hasOwnProperty(key)) {\r\n        if (Array.isArray(value)) {\r\n          if (value.length === 1) {\r\n            // Set keyvalue to first (and only) array value.\r\n            copy[key] = DgraphAdapterHttp.flattenArraysInObject(value[0]);\r\n          } else {\r\n            // Retain original array\r\n            copy[key] = DgraphAdapterHttp.flattenArraysInObject(value);\r\n          }\r\n        } else {\r\n          copy[key] = DgraphAdapterHttp.flattenArraysInObject(value);\r\n        }\r\n      }\r\n    });\r\n    return copy;\r\n  }\r\n\r\n  /**\r\n   * Execute a database mutation using passed payload object or BaseModel<T> instance.\r\n   * @param {any | BaseModel<T>} serialization\r\n   * @param {MutationTypes} mutationType\r\n   * @param {boolean} commitNow\r\n   * @param {boolean} ignoreIndexConflict\r\n   * @returns {Promise<Partial<T>>}\r\n   */\r\n  async mutate<T>(\r\n    serialization: Serialization,\r\n    mutationType: MutationTypes = MutationTypes.SetJson,\r\n    commitNow = false\r\n  ): Promise<Serialization> {\r\n    if (serialization.request === undefined) {\r\n      throw Error(\r\n        `DgraphAdapterHttp.mutate error, payload undefined for data: ${\r\n          serialization.data\r\n        }`\r\n      );\r\n    }\r\n    const transaction = this.client.newTxn();\r\n    const uids: string[] = [];\r\n    logger.debug('----------');\r\n    logger.debug('DgraphAdapterHttp.mutate, payload: %o', serialization);\r\n    logger.debug('----------');\r\n    try {\r\n      const payload: any = {};\r\n      payload.commitNow = commitNow;\r\n      switch (mutationType) {\r\n        case MutationTypes.SetJson:\r\n          payload.setJson = serialization.request;\r\n          break;\r\n        case MutationTypes.DeleteJson:\r\n          payload.deleteJson = serialization.request;\r\n          break;\r\n      }\r\n      const assigned = await transaction.mutate(payload);\r\n      if (!commitNow) await transaction.commit();\r\n      Object.entries(assigned.data.uids).forEach(([key, uid]) =>\r\n        uids.push(uid)\r\n      );\r\n    } catch (e) {\r\n      logger.error(\r\n        'DgraphAdapterHttp.mutate, payload: %o, mutationType: %o, error: %o',\r\n        serialization,\r\n        mutationType,\r\n        e\r\n      );\r\n    } finally {\r\n      await transaction.discard();\r\n    }\r\n    // Assign generated uids\r\n    if (uids.length > 0) serialization.uid = uids;\r\n    return serialization;\r\n  }\r\n\r\n  /**\r\n   * Execute a database query.\r\n   * @param {string} serialization\r\n   * @returns {Promise<string>}\r\n   */\r\n  async query<T>(serialization: Serialization): Promise<Serialization> {\r\n    const transaction = this.client.newTxn();\r\n    try {\r\n      const res = await transaction.query(serialization.request);\r\n      serialization.response = DgraphAdapterHttp.flattenArrays(res.data);\r\n    } catch (e) {\r\n      logger.error('DgraphAdapterHttp.query, error: %o', e);\r\n    } finally {\r\n      await transaction.discard();\r\n    }\r\n    return serialization;\r\n  }\r\n\r\n  /**\r\n   * Execute a database query with paramTypes.\r\n   * @param {string} serialization\r\n   * @param vars\r\n   * @returns {Promise<any>}\r\n   */\r\n  async queryWithVars(\r\n    serialization: Serialization,\r\n    vars?: any\r\n  ): Promise<Serialization> {\r\n    const transaction = this.client.newTxn();\r\n    try {\r\n      const res = await transaction.queryWithVars(serialization.request, vars);\r\n      serialization.response = DgraphAdapterHttp.flattenArrays(res.data);\r\n    } catch (e) {\r\n      logger.error(\r\n        'DgraphAdapterHttp.queryWithVars, query: %s, paramTypes: %o, error: %o',\r\n        serialization,\r\n        vars,\r\n        e\r\n      );\r\n    } finally {\r\n      await transaction.discard();\r\n    }\r\n    return serialization;\r\n  }\r\n}\r\n"]}