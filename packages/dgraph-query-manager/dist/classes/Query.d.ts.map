{"version":3,"sources":["../packages/dgraph-query-manager/src/classes/Query.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AAGxC,oBAAY,WAAW;IACrB,MAAM,IAAA;IACN,GAAG,IAAA;IACH,IAAI,IAAA;IACJ,GAAG,IAAA;CACJ;AAED,MAAM,WAAW,cAAc;IAC7B,UAAU,EAAE,WAAW,CAAC;IACxB,UAAU,EAAE,MAAM,CAAC;IACnB,MAAM,EAAE,MAAM,CAAC;IACf,UAAU,CAAC,EAAE,SAAS,CAAC,GAAG,CAAC,EAAE,CAAC;IAC9B,KAAK,EAAE,MAAM,CAAC;IACd,KAAK,EAAE,MAAM,CAAC;IACd,IAAI,EAAE,MAAM,EAAE,EAAE,CAAC;CAClB;AAED;;GAEG;AACH,qBAAa,KAAM,YAAW,cAAc;IAC1C,OAAO,CAAC,WAAW,CAAS;IACxB,UAAU,EAAI,MAAM;IAUxB,MAAM,EAAE,MAAM,CAAC;IAWf,UAAU,EAAE,WAAW,CAAmB;IAC1C,UAAU,CAAC,EAAE,SAAS,CAAC,GAAG,CAAC,EAAE,CAAC;IAC9B,KAAK,EAAE,MAAM,CAAC;IACd,KAAK,EAAE,MAAM,CAAC;IACd,IAAI,EAAE,MAAM,EAAE,EAAE,CAAM;IAEtB;;;;;;;OAOG;gBAED,KAAK,EAAE,MAAM,EACb,KAAK,EAAE,MAAM,EACb,UAAU,CAAC,EAAE,SAAS,CAAC,GAAG,CAAC,EAAE,EAC7B,IAAI,CAAC,EAAE,MAAM,GAAG,MAAM,EAAE,EACxB,UAAU,GAAE,WAA6B,EACzC,MAAM,CAAC,EAAE,MAAM;IAUjB;;;OAGG;IACH,MAAM,CAAC,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,KAAK,CAAC,GAAG,GAAG;IAW3C;;;OAGG;IACH,OAAO,CAAC,sBAAsB;IAK9B;;;OAGG;IACH,OAAO,CAAC,SAAS;IAWjB;;;OAGG;IACH,GAAG,CAAC,MAAM,CAAC,EAAE,MAAM,GAAG,MAAM,GAAG,SAAS;IAWxC;;;OAGG;IACH,kBAAkB;IAmBlB;;;OAGG;IACH,cAAc;CAwCf","file":"Query.d.ts","sourcesContent":["import logger from '../logger';\r\nimport { ParamType } from './ParamType';\r\nimport { http } from 'winston';\r\n\r\nexport enum HttpMethods {\r\n  DELETE,\r\n  GET,\r\n  POST,\r\n  PUT\r\n}\r\n\r\nexport interface QueryInterface {\r\n  httpMethod: HttpMethods;\r\n  objectType: string;\r\n  params: object;\r\n  paramTypes?: ParamType<any>[];\r\n  query: string;\r\n  route: string;\r\n  tree: string[][];\r\n}\r\n\r\n/**\r\n * Helper class for creating queries to be executed by Dgraph via dgraph-adapter.\r\n */\r\nexport class Query implements QueryInterface {\r\n  private _objectType: string;\r\n  get objectType(): string {\r\n    // Set initial value if not specified.\r\n    if (!this._objectType) this.objectType = this.getObjectTypeFromRoute();\r\n    return this._objectType;\r\n  }\r\n\r\n  set objectType(value: string) {\r\n    this._objectType = value;\r\n  }\r\n\r\n  params: object;\r\n\r\n  // private _params: object = {};\r\n  // get params(): object {\r\n  //   return this._params;\r\n  // }\r\n  //\r\n  // set params(value: object) {\r\n  //   this._params = value;\r\n  // }\r\n\r\n  httpMethod: HttpMethods = HttpMethods.GET;\r\n  paramTypes?: ParamType<any>[];\r\n  query: string;\r\n  route: string;\r\n  tree: string[][] = [];\r\n\r\n  /**\r\n   * @param query - Query string.\r\n   * @param route - REST_API route.\r\n   * @param paramTypes? - Collection of valid parameter types.\r\n   * @param tree? - Results tree definition.\r\n   * @param httpMethod\r\n   * @param params\r\n   */\r\n  constructor(\r\n    query: string,\r\n    route: string,\r\n    paramTypes?: ParamType<any>[],\r\n    tree?: string | string[],\r\n    httpMethod: HttpMethods = HttpMethods.GET,\r\n    params?: object\r\n  ) {\r\n    this.paramTypes = paramTypes;\r\n    this.parseTree(tree);\r\n    this.query = query;\r\n    this.route = route;\r\n    this.httpMethod = httpMethod;\r\n    if (params) this.params = params;\r\n  }\r\n\r\n  /**\r\n   * Builds a Query instance from partial params.\r\n   * @param params\r\n   */\r\n  static factory(params: Partial<Query> | any) {\r\n    return new Query(\r\n      params.query,\r\n      params.route,\r\n      params.paramTypes,\r\n      undefined,\r\n      params.httpMethod,\r\n      params.params\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Parses the route string and obtains assumed retrieved object type.\r\n   * e.g. '/tweets/:uid' returns 'tweets'\r\n   */\r\n  private getObjectTypeFromRoute(): string {\r\n    const value = this.route.split('/')[1];\r\n    return value ? value : 'Unknown';\r\n  }\r\n\r\n  /**\r\n   * Splits the passed period-delimited tree string into array.\r\n   * @param tree\r\n   */\r\n  private parseTree(tree?: string | string[]) {\r\n    if (!tree) return;\r\n    if (tree instanceof Array) {\r\n      for (const element of tree) {\r\n        this.tree.push(element.split('.'));\r\n      }\r\n    } else if (typeof tree === 'string') {\r\n      this.tree.push(tree.split('.'));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generates the proper URI from route and passed params.\r\n   * @param params\r\n   */\r\n  uri(params?: object): string | undefined {\r\n    let newUri = this.route;\r\n    if (params) {\r\n      // replace $ in params with :\r\n      Object.entries(params).forEach(([key, value]) => {\r\n        newUri = newUri.replace(key.replace('$', ':'), value);\r\n      });\r\n    }\r\n    return newUri;\r\n  }\r\n\r\n  /**\r\n   * Injects custom params into query strings.  Useful for 'building' queries at runtime.\r\n   * @param params\r\n   */\r\n  injectCustomParams() {\r\n    // this.params = params ? params : this.params;\r\n\r\n    // Get all paramTypes that require substitution.\r\n    const subParamTypes: ParamType<any>[] = this.paramTypes\r\n      ? this.paramTypes.filter(paramType => paramType.isSubstitution === true)\r\n      : [];\r\n\r\n    subParamTypes.forEach(paramType => {\r\n      // Replace key value in param with param value.\r\n      this.query = this.query.replace(\r\n        paramType.key,\r\n        this.params[paramType.key]\r\n      );\r\n      // Remove from params prior to Dgraph mutation submission.\r\n      delete this.params[paramType.key];\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Validates passed params with specified paramTypes, if applicable.\r\n   * @param params\r\n   */\r\n  validateParams() {\r\n    const paramTypes = this.paramTypes;\r\n    if (!this.params) {\r\n      if (paramTypes) {\r\n        logger.error(`No params found for query: ${this.query}`);\r\n        return false;\r\n      }\r\n    } else {\r\n      if (paramTypes) {\r\n        paramTypes.forEach(paramType => {\r\n          // Check that params contain this paramType key.\r\n          if (this.params.hasOwnProperty(paramType.key)) {\r\n            // Skip undefined or null\r\n            if (this.params[paramType.key]) {\r\n              // Checks that constructor type of parameter matches paramType.\r\n              if (\r\n                this.params[paramType.key].constructor.name !==\r\n                paramType.type.constructor.name\r\n              ) {\r\n                logger.error(\r\n                  `Param for key of (${\r\n                    paramType.key\r\n                  }) must match constructor paramType of (${\r\n                    paramType.type.constructor.name\r\n                  }).`\r\n                );\r\n                return false;\r\n              }\r\n            }\r\n          } else {\r\n            logger.error(\r\n              `Params must contain paramType key of (${paramType.key}).`\r\n            );\r\n            return false;\r\n          }\r\n        });\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n}\r\n"]}